
// SPDX-License-Identifier: Apache-2.0.
//---------------------------------------------------------------------------//
// Copyright (c) 2023 Generated by ZKLLVM-transpiler
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//---------------------------------------------------------------------------//
pragma solidity >=0.8.4;

import "../../cryptography/transcript.sol";
import "../../interfaces/modular_commitment.sol";
// Move away unused structures from types.sol
import "../../types.sol";
import "../../basic_marshalling.sol";
import "../../containers/merkle_verifier.sol";
import "../../algebra/polynomial.sol";
import "hardhat/console.sol";

library modular_commitment_scheme_circuit5_chunk10_lpc {
    uint256 constant modulus = 28948022309329048855892746252171976963363056481941560715954676764349967630337;
    uint64 constant batches_num = 4;
    uint256 constant r = 4;
    uint256 constant lambda = 10;
    uint256 constant D0_size = 512;
    uint256 constant D0_log = 9;
    uint256 constant max_degree = 31;
    uint256 constant D0_omega = 22954361264956099995527581168615143754787441159030650146191365293282410739685;
    uint256 constant unique_points = 3;
    uint256 constant omega = 3612152772817685532768635636100598085437510685224817206515049967552954106764;
    uint256 constant _eta = 8143998860911406739748240614052334388097573721582448591644906161113633999668;
    uint64  constant fixed_batch_size = 65;
    bytes constant point_ids = hex"0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000100010002000102000102000102000102000102000102000102000102000102000102000102000102000102000102000102000102000102000102000102000102000102000102000102000102000102000102000102000102000102000100000100000000000000000000000000"; // 1 byte -- point id
    bytes constant poly_points_num = hex"006e0021001e"; // 2 byte lengths
    bytes constant poly_ids = hex"00000040008000c001000140018001c002000240028002c003000340038003c004000440048004c005000540058005c006000640068006c007000740078007c008000840088008c009000940098009c00a000a400a800ac00b000b400b800bc00c000c400c800cc00d000d400d800dc00e000e400e800ec00f000f400f800fc010001040108010c011001140118011c012001240128012c013001340138013c014001440148014c015001540158015c016001640168016c017001740178017c018001840188018c019001940198019c01a001a401a801ac01b001b400f800fc01040108010c011001140118011c012001240128012c013001340138013c014001440148014c015001540158015c016001640168016c017001740178018001040108010c011001140118011c012001240128012c013001340138013c014001440148014c015001540158015c016001640168016c0170017401780"; // 2 byte poly_id 2 byte

    struct commitment_state{
        bytes   leaf_data;
        uint256 roots_offset;
        uint256 query_proof_offset;
        uint256 initial_data_offset;
        uint256 initial_proof_offset;
        uint256 round_proof_offset;
        uint256 round_data_offset;
        uint256[r]  alphas;
        uint64[batches_num] batch_sizes;
        uint64 poly_num;
        uint256 points_num;
        uint256 theta;
        uint256 x_index;
        uint256 x;
        uint256 max_batch;
        uint256 domain_size;
        uint256[] final_polynomial;
        uint256 leaf_length;
        uint256[2][unique_points+1] denominators;
        uint256[unique_points+1] U;
        uint256[unique_points] unique_eval_points;
        uint256[unique_points+1] theta_factors;
        uint256[2] y;
        uint256[2] Q;
        uint256 j;
        uint256 offset;
        uint256 interpolant;
        uint16[][unique_points] poly_inds;
    }


    function prepare_eval_points(uint256[unique_points] memory result, uint256 xi) internal view {
        uint256 inversed_omega = field.inverse_static(omega, modulus);
		result[0] = xi;
		result[1] = mulmod(xi, omega, modulus);
		result[2] = mulmod(xi, inversed_omega, modulus);

    }

    function prepare_Y(bytes calldata blob, uint256 offset, commitment_state memory state) internal pure {
        unchecked{
            state.y[0] = 0;
            state.y[1] = 0;
            for(uint256 cur_point = unique_points; cur_point > 0; ){
                cur_point--;
                for(uint256 cur_poly = state.poly_inds[cur_point].length; cur_poly > 0;){
                    cur_poly--;
                    uint256 cur_offset = state.poly_inds[cur_point][cur_poly];
                    cur_offset = state.query_proof_offset + cur_offset;
                    state.Q[0] = mulmod(state.Q[0], state.theta, modulus);
                    state.Q[1] = mulmod(state.Q[1], state.theta, modulus);
                    state.Q[0] = addmod(state.Q[0], basic_marshalling.get_uint256_be(blob, cur_offset), modulus);
                    state.Q[1] = addmod(state.Q[1], basic_marshalling.get_uint256_be(blob, cur_offset + 0x20), modulus);
                }
                state.Q[0] = addmod(state.Q[0], modulus - state.U[cur_point], modulus);
                state.Q[1] = addmod(state.Q[1], modulus - state.U[cur_point], modulus);
                state.Q[0] = mulmod(state.Q[0], state.denominators[cur_point][0], modulus);
                state.Q[1] = mulmod(state.Q[1], state.denominators[cur_point][1], modulus);
                state.Q[0] = mulmod(state.Q[0], state.theta_factors[cur_point], modulus);
                state.Q[1] = mulmod(state.Q[1], state.theta_factors[cur_point], modulus);
                state.y[0] = addmod(state.y[0], state.Q[0], modulus);
                state.y[1] = addmod(state.y[1], state.Q[1], modulus);
                state.Q[0] = 0;
                state.Q[1] = 0;
            }
            for( uint256 cur_poly = fixed_batch_size; cur_poly > 0; ){
                cur_poly--;
                uint256 cur_offset = cur_poly * 0x40;
                cur_offset = state.query_proof_offset + cur_offset;
                state.Q[0] = mulmod(state.Q[0], state.theta, modulus);
                state.Q[1] = mulmod(state.Q[1], state.theta, modulus);
                state.Q[0] = addmod(state.Q[0], basic_marshalling.get_uint256_be(blob, cur_offset), modulus);
                state.Q[1] = addmod(state.Q[1], basic_marshalling.get_uint256_be(blob, cur_offset + 0x20), modulus);
            }
            state.Q[0] = addmod(state.Q[0], modulus - state.U[unique_points], modulus);
            state.Q[1] = addmod(state.Q[1], modulus - state.U[unique_points], modulus);
            state.Q[0] = mulmod(state.Q[0], state.denominators[unique_points][0], modulus);
            state.Q[1] = mulmod(state.Q[1], state.denominators[unique_points][1], modulus);
            state.Q[0] = mulmod(state.Q[0], state.theta_factors[unique_points], modulus);
            state.Q[1] = mulmod(state.Q[1], state.theta_factors[unique_points], modulus);
            state.y[0] = addmod(state.y[0], state.Q[0], modulus);
            state.y[1] = addmod(state.y[1], state.Q[1], modulus);
            state.Q[0] = 0;
            state.Q[1] = 0;
        }
    }

    function initialize(
        bytes32 tr_state_before
    ) internal returns(bytes32 tr_state_after){
        types.transcript_data memory tr_state;
        tr_state.current_challenge = tr_state_before;
        uint256 eta = transcript.get_field_challenge(tr_state, modulus);
        require(eta == _eta, "Wrong eta");
        tr_state_after = tr_state.current_challenge;
    }

    function copy_memory_pair_and_check(bytes calldata blob, uint256 proof_offset, bytes memory leaf, uint256[2] memory pair)
    internal pure returns(bool b){
        uint256 c = pair[0];
        uint256 d = pair[1];
        assembly{
            mstore(
                add(leaf, 0x20),
                c
            )
            mstore(
                add(leaf, 0x40),
                d
            )
        }
        if( !merkle_verifier.parse_verify_merkle_proof_bytes_be(blob, proof_offset, leaf, 0x40 )){
            return false;
        } else {
            return true;
        }
    }

    function copy_reverted_memory_pair_and_check(bytes calldata blob, uint256 proof_offset, bytes memory leaf, uint256[2] memory pair)
    internal pure returns(bool b){
        uint256 c = pair[0];
        uint256 d = pair[1];
        assembly{
            mstore(
                add(leaf, 0x20),
                d
            )
            mstore(
                add(leaf, 0x40),
                c
            )
        }
        if( !merkle_verifier.parse_verify_merkle_proof_bytes_be(blob, proof_offset, leaf, 0x40 )){
            return false;
        } else {
            return true;
        }
    }

    function copy_pairs_and_check(bytes calldata blob, uint256 offset, bytes memory leaf, uint256 size, uint256 proof_offset)
    internal pure returns(bool b){
        unchecked {
            uint256 offset2 = 0x20;
            for(uint256 k = 0; k < size;){
                assembly{
                    mstore(
                        add(leaf, offset2),
                        calldataload(add(blob.offset, offset))
                    )
                    mstore(
                        add(leaf, add(offset2, 0x20)),
                        calldataload(add(blob.offset, add(offset, 0x20)))
                    )
                }
                k++; offset2 += 0x40; offset += 0x40;
            }
            if( !merkle_verifier.parse_verify_merkle_proof_bytes_be(blob, proof_offset, leaf, offset2 - 0x20 )){
                return false;
            } else {
                return true;
            }
        }
    }

    function copy_reverted_pairs_and_check(bytes calldata blob, uint256 offset, bytes memory leaf, uint256 size, uint256 proof_offset)
    internal pure returns(bool){
        unchecked {
            uint256 offset2 = 0x20;
            for(uint256 k = 0; k < size;){
                assembly{
                    mstore(
                        add(leaf, offset2),
                        calldataload(add(blob.offset, add(offset, 0x20)))
                    )
                    mstore(
                        add(leaf, add(offset2, 0x20)),
                        calldataload(add(blob.offset, offset))
                    )
                }
                k++; offset2 += 0x40; offset += 0x40;
            }
            if( !merkle_verifier.parse_verify_merkle_proof_bytes_be(blob, proof_offset, leaf, offset2 - 0x20 )){
                return false;
            } else {
                return true;
            }
        }
    }

    function colinear_check(uint256 x, uint256[2] memory y, uint256 alpha, uint256 colinear_value) internal pure returns(bool){
        unchecked {
            uint256 tmp;
            tmp = addmod(y[0], y[1], modulus);
            tmp = mulmod(tmp, x, modulus);
            tmp = addmod(
                tmp,
                mulmod(
                    alpha,
                    addmod(y[0], modulus-y[1], modulus),
                    modulus
                ),
                modulus
            );
            uint256 tmp1 = mulmod(colinear_value , 2, modulus);
            tmp1 = mulmod(tmp1 , x, modulus);
            if( tmp !=  tmp1 ){
                return false;
            }
        return true;
        }
    }

    function prepare_eta_U(uint256 theta) internal pure returns (uint256 result){
		result = addmod(0xfc0700301a489452f54d9dceaaf096bbbdbc88e47792d0b8b71c665f628f0fc, mulmod(result, theta, modulus), modulus);
		result = addmod(0x34ca65afab74ba489aa3392b99ca4c96f5a04cd49cebe426d8868a3b67d5c73e, mulmod(result, theta, modulus), modulus);
		result = addmod(0x22ab935040ca6de458eed4ef0933793a46915415574cc823255dd457b3fe58b6, mulmod(result, theta, modulus), modulus);
		result = addmod(0x2c3f61decfda9b733508f4955be472c7be51122eefd38540a8fad3846385a95a, mulmod(result, theta, modulus), modulus);
		result = addmod(0x3bf068d60981586222926a238984491cd94100dedeb3b10e3aeea4235b4806db, mulmod(result, theta, modulus), modulus);
		result = addmod(0x2907e978db66ef84ef3f911c8f783ae261ceea828257f1f2e3e23ff233902b24, mulmod(result, theta, modulus), modulus);
		result = addmod(0x27afe96c5030de92075ade64b7afeefc6579d9d0a77178757812a9177f9c5e70, mulmod(result, theta, modulus), modulus);
		result = addmod(0x3eb4f67e59f4a1186a6ba6aad5c863d07871875bb47b3de2c138ddbb0d76c23b, mulmod(result, theta, modulus), modulus);
		result = addmod(0x3fedadc40fad2b6000223f9b0d97e82b8a405402bbb72dbad30f6cb94032c86c, mulmod(result, theta, modulus), modulus);
		result = addmod(0x10fba14536aa524d7efb5a0b8b2faff6b20328810f72fe876577f785b9fdde53, mulmod(result, theta, modulus), modulus);
		result = addmod(0x2d723f226462f65bddf3d8dd6b42633f5b9f1db453b5d6cbfe8810573b6362d4, mulmod(result, theta, modulus), modulus);
		result = addmod(0x290855728afb06a6f5a310f2f12ff251e3f5b5b1e085bd3d2a6e1decbd7c1b28, mulmod(result, theta, modulus), modulus);
		result = addmod(0x381ba9c1a4423b1eb2181897bbb496f1caa90f4a91df39596d27489b8cfd36b5, mulmod(result, theta, modulus), modulus);
		result = addmod(0x25d1473dd10994f69c2d547d98c765a81e1867d8fc4d61c0fcd560c111027cd4, mulmod(result, theta, modulus), modulus);
		result = addmod(0x3f9fdaceeef466b1f03ab6ce3e186314a73a0aea3ee23a5ab28bb99c3d1a8071, mulmod(result, theta, modulus), modulus);
		result = addmod(0x8c5bef72ea66545ada34a2d06951ac1ae92b78dc161e729cf01f7c755a1fb01, mulmod(result, theta, modulus), modulus);
		result = addmod(0xb039db10466c4b62e417343b36be1317cbab936f40d9edeac0352764e6c92ec, mulmod(result, theta, modulus), modulus);
		result = addmod(0x1c62f50ca192a710ab6edba6aa19317e9fc7ef9dd3d3002af852e5c6f80dd340, mulmod(result, theta, modulus), modulus);
		result = addmod(0x2386dd9724d546895d87ddd9169c7923ea990c5d7a461d16aaef30633c1c2583, mulmod(result, theta, modulus), modulus);
		result = addmod(0x1ac7625852e140073b414b239dde4dd06cb1790465b57cee0606d82c1c16eb95, mulmod(result, theta, modulus), modulus);
		result = addmod(0x1f10f19b63d76d1cc0afa29b0ed5dd6825476c26a3f7471c397b1f4f8b0a7d56, mulmod(result, theta, modulus), modulus);
		result = addmod(0xf91f56aa0de04c7a49a716ff566999eb276ba4903c53b8c8f4e047fc74d2280, mulmod(result, theta, modulus), modulus);
		result = addmod(0xa08765ac8a9b8b07c9d88842fafd51d7ff1a2ef45c28c8161454ec0b28fe44b, mulmod(result, theta, modulus), modulus);
		result = addmod(0xb3cb643116a49f4e32c6dea254ac3680aea90f9eaa8ef6a369f84c3962bb185, mulmod(result, theta, modulus), modulus);
		result = addmod(0x20f74c905cc36d5dc2f5e1c57d252dfdea42b3e6b8da29dd90cce1dad541b88, mulmod(result, theta, modulus), modulus);
		result = addmod(0x3c36ff3d673ac156e0482be5ef7f28a5520abd219b4e243f8954785f0f1d1c12, mulmod(result, theta, modulus), modulus);
		result = addmod(0x15317a9154cada5e9b800eb946e094dff3cf57690914c43eabc4f9fa866ecf41, mulmod(result, theta, modulus), modulus);
		result = addmod(0x3de53617cd41564b22a7509198d70c1af58337e80bdb581ece13c23c36145544, mulmod(result, theta, modulus), modulus);
		result = addmod(0x3613d88d3a303dde85f6c7b5f98002575d9ec33510d327ac67cb8f1ed6ec7962, mulmod(result, theta, modulus), modulus);
		result = addmod(0x303839385b73b66f3bd5a52b8b765299d9095b3c93f0112893bb94eacfc5d998, mulmod(result, theta, modulus), modulus);
		result = addmod(0x1e620baf19f1752f3af914b9fc5a5b5f19bb06e21c533ac1eefab23c230d90d9, mulmod(result, theta, modulus), modulus);
		result = addmod(0x306dd5886cbac6b427cd78216b81d8225962416589a3c5b946cda18bbd993ba8, mulmod(result, theta, modulus), modulus);
		result = addmod(0x1714743050a0a7a2e71e40f0873ab3f3ded6d6f7c23a61905f80bbba9b8df808, mulmod(result, theta, modulus), modulus);
		result = addmod(0x2bdc4a4c14e376fd1ad3cf4ce7f609526d3692ccf8d2fd216dc5acb7560d5461, mulmod(result, theta, modulus), modulus);
		result = addmod(0x159c8387df586cd0513be72397358ce17f84ac316c2628b5e7383765fec5450f, mulmod(result, theta, modulus), modulus);
		result = addmod(0x45280b4c644e290103f2e3a51711c2d1980ef3d15a13b5794a4d7e132f44103, mulmod(result, theta, modulus), modulus);
		result = addmod(0xdd4cf0f4742d50033fd60ba9e36c090519c9729ded0bde50edc4c6a3ca7367, mulmod(result, theta, modulus), modulus);
		result = addmod(0x335f75c9ca7da2a99a3ff79beec7159b82d73c46f3d363428aba1b4bba5bb0af, mulmod(result, theta, modulus), modulus);
		result = addmod(0x3d797df5287f86eeb87331859627d11f3596b9a49e9b0e5696495fccbedf2357, mulmod(result, theta, modulus), modulus);
		result = addmod(0x19184c643b4cb49624e3d6b4513b29d31192aa202194ce4a097e1cf1f2f96d78, mulmod(result, theta, modulus), modulus);
		result = addmod(0x2b6b427a72428a846dc72af0dd0bd52a4b47b1040c4bf1ec2a9abcbe96feaf7f, mulmod(result, theta, modulus), modulus);
		result = addmod(0x2248a6e54a0d4ee74927d5635f68c43bb65dc6ff39612da0ac31061e8499564d, mulmod(result, theta, modulus), modulus);
		result = addmod(0x3a0e87c77535dc94a83b2aad797b5a7273180896461dd06969c78ec3b41eaadd, mulmod(result, theta, modulus), modulus);
		result = addmod(0xb9c818e4aa45f50ee723bbc4b7f1216e3d19b51413929aeaec182f3f0d2eef9, mulmod(result, theta, modulus), modulus);
		result = addmod(0xf1f4d1c755413102fb07258dbe636d1679e70dc421ad3c20e62f0c696909632, mulmod(result, theta, modulus), modulus);
		result = addmod(0xfd30f6c177737033cbce3ab5f2e0af6b52dcec4dbe18f5f87e9a0571e1cead7, mulmod(result, theta, modulus), modulus);
		result = addmod(0x29909caf37e4a49a3f58fa55796f9bcb0599eb8b64c1b223aa49d7060605c892, mulmod(result, theta, modulus), modulus);
		result = addmod(0x3b835289719420eba644fedde516525be9574318b5311e1d3632ebbece01281e, mulmod(result, theta, modulus), modulus);
		result = addmod(0x2580aa1b7d1da02f2140ffc5fa9e1078d5fa7dd027f569aa7b4f75eb5c66a1a0, mulmod(result, theta, modulus), modulus);
		result = addmod(0x78022057f6c533ca04033279886034b5dfee5f66e6448554bdcb12f127aed20, mulmod(result, theta, modulus), modulus);
		result = addmod(0x34b33a01197c10a5b9a670a184e79a42616b752e1d84d5c0bce9e42d6a1895d4, mulmod(result, theta, modulus), modulus);
		result = addmod(0xa8a3ecd0518d021252149b9e761854079e24aa2d2b42ac025c860d5e204eac4, mulmod(result, theta, modulus), modulus);
		result = addmod(0x1bb53fc29a9e9006a106a8586179e77359497f522ddc6c317806f3bcc6cdc88e, mulmod(result, theta, modulus), modulus);
		result = addmod(0x2bf10cc08552e99aed0154de79e52e4a599f754141f3de4da71c814d8e29281d, mulmod(result, theta, modulus), modulus);
		result = addmod(0x2f3035c01aaa2eb895cd10f94b943c7559b0a67112c55b867d5404041c6ea1a0, mulmod(result, theta, modulus), modulus);
		result = addmod(0x9700ac005553c8b512903650f1da5b111f02149d08ddf1ae5dd9a6738e2ed20, mulmod(result, theta, modulus), modulus);
		result = addmod(0xeb0022667777282436e9a47696c5456a40af20df85ef80ae6355bdda4fa2f6d, mulmod(result, theta, modulus), modulus);
		result = addmod(0x2f0006e14b17d4d40afb874aeaf44115402306931ac98022e0aabf920fed649, mulmod(result, theta, modulus), modulus);
		result = addmod(0x33c999af9dbd190f7356581756230d9d2c38ea7844934c1683bfe322a032f7a9, mulmod(result, theta, modulus), modulus);
		result = addmod(0xa5b85231f8c38364a447804aad3cf85d5a4fbb1a750a8d14d8cc706ecd6fe55, mulmod(result, theta, modulus), modulus);
		result = addmod(0x35458107064f3e71420db19a8890c31adfbfdfed28e74f7323a6b55895c49945, mulmod(result, theta, modulus), modulus);
		result = addmod(0xaa780349adca616a6cf89ebb4e9c09ef98cc662a1c7dcb0a0baf111b78db841, mulmod(result, theta, modulus), modulus);
		result = addmod(0x221800a855f546aee2981fbf0fb8cec984f5ae086c19289b9befd038b1c580d, mulmod(result, theta, modulus), modulus);
		result = addmod(0x1a06b3354ddfddaefc6eb398c9cbe8fc2c2c1c2b51df1a8cfc0512f91bd27803, mulmod(result, theta, modulus), modulus);
		result = addmod(0x1201570aa92cc5efcc1623eb5b8f2e98dc7d576e456f3721b77073fad25d4b34, mulmod(result, theta, modulus), modulus);

    }

    function verify_eval(
        bytes calldata blob,
        uint256[5] memory commitments,
        uint256 challenge,
        bytes32 transcript_state
    ) internal view returns (bool){
unchecked {
        types.transcript_data memory tr_state;
        tr_state.current_challenge = transcript_state;
        commitment_state memory state;

        {
            uint256 offset;

            uint256 challenge2 = transcript.get_field_challenge(tr_state, modulus);
            if (challenge!= challenge2) {
                console.log("Wrong challenge");
                return false;
            }

            for(uint8 i = 0; i < batches_num;){
                transcript.update_transcript_b32(tr_state, bytes32(commitments[i]));
                i++;
            }
            state.theta = transcript.get_field_challenge(tr_state, modulus);

            state.points_num = basic_marshalling.get_length(blob, 0x0);
            offset = 0x10 + state.points_num * 0x20;
            for(uint8 i = 0; i < batches_num;){
                state.batch_sizes[i] = uint64(uint8(blob[offset + 0x1]));
                if( state.batch_sizes[i] > state.max_batch ) state.max_batch = state.batch_sizes[i];
                state.poly_num += state.batch_sizes[i];
                i++; offset +=2;
            }

            offset += 0x8;
            offset += state.poly_num;
            state.roots_offset = offset + 0x8;
            offset += 0x8;

            for( uint8 i = 0; i < r;){
                transcript.update_transcript_b32(tr_state, bytes32(basic_marshalling.get_uint256_be(blob, offset + 0x8)));
                state.alphas[i] = transcript.get_field_challenge(tr_state, modulus);
                i++; offset +=40;
            }

            

            offset += 0x8 + r;
            state.initial_data_offset = offset + 0x8;
            offset += 0x8 + 0x20*basic_marshalling.get_length(blob, offset);

            state.round_data_offset = offset + 0x8;
            offset += 0x8 + 0x20*basic_marshalling.get_length(blob, offset);
            offset += 0x8;

            state.initial_proof_offset = offset;
            for(uint256 i = 0; i < lambda;){
                for(uint256 j = 0; j < batches_num;){
                    if(basic_marshalling.get_uint256_be(blob, offset + 0x10) != commitments[j] ) return false;
                    offset = merkle_verifier.skip_merkle_proof_be(blob, offset);
                    j++;
                }
                i++;
            }
            offset += 0x8;
            state.round_proof_offset = offset;

            for(uint256 i = 0; i < lambda;){
                for(uint256 j = 0; j < r;){
                    if(basic_marshalling.get_uint256_be(blob, offset + 0x10) != basic_marshalling.get_uint256_be(blob, state.roots_offset + j * 40 + 0x8) ) return false;
                    offset = merkle_verifier.skip_merkle_proof_be(blob, offset);
                    j++;
                }
                i++;
            }

            state.final_polynomial = new uint256[](basic_marshalling.get_length(blob, offset));
            offset += 0x8;
            for (uint256 i = 0; i < state.final_polynomial.length;) {
                state.final_polynomial[i] = basic_marshalling.get_uint256_be(blob, offset);
                i++; offset+=0x20;
            }
        }
        if( state.final_polynomial.length > (( 1 << (field.log2(max_degree + 1) - r + 1) ) ) ){
            console.log("Wrong final poly degree");
            return false;
        }

        prepare_eval_points(state.unique_eval_points, challenge);
        // Prepare U
        {
            uint256 sum;

            for(uint256 i = 0; i < state.unique_eval_points.length;){
                state.theta_factors[i] = field.pow_small(state.theta, sum, modulus);
                sum += (uint256(uint8(poly_points_num[2*i])) << 8) + uint256(uint8(poly_points_num[2*i + 1]));
                i++;
            }
            state.theta_factors[unique_points] = field.pow_small(state.theta, sum, modulus);

            uint256 off = point_ids.length * 0x20 - 0x18;
            for(uint256 i = 0; i < point_ids.length;){
                uint256 p = uint256(uint8(point_ids[point_ids.length - i - 1]));
                state.U[p] = mulmod(state.U[p], state.theta, modulus);
                state.U[p] = addmod(state.U[p], basic_marshalling.get_uint256_be(blob, off), modulus);
                off -= 0x20;
                i++;
            }
            state.U[unique_points] = prepare_eta_U(state.theta);
        }

        uint64 cur = 0;
        for(uint64 p = 0; p < unique_points; p++){
            state.poly_inds[p] = new uint16[]((uint16(uint8(poly_points_num[2*p])) << 8) + uint16(uint8(poly_points_num[2*p + 1])));
            for(uint64 i = 0; i < state.poly_inds[p].length; i++){
                state.poly_inds[p][i] = (uint16(uint8(poly_ids[cur])) << 8) + uint16(uint8(poly_ids[cur + 1]));
                cur+=2;
            }
        }

        state.leaf_data = new bytes(state.max_batch * 0x40 + 0x40);
        for(uint64 i = 0; i < lambda;){
            // Initial proofs
            state.query_proof_offset = state.initial_data_offset;
            state.x = transcript.get_field_challenge(tr_state, modulus);
            state.x = field.pow_small(state.x, (modulus-1) / D0_size , modulus);
            state.x_index = 0;
            for( uint64 j = 0; j < D0_log - 1; j++){
                state.x_index += (uint64(1 - uint8(blob[state.initial_proof_offset + 0x47 + 0x38 * j])) << j );
            }
            {
                uint256 tmp = field.pow_small(D0_omega, state.x_index, modulus);
                if( tmp != state.x ){
                    state.x_index += D0_size/2;
                    tmp = modulus - tmp;
                    if( tmp != state.x ){
                        console.log("Wrong x_index");
                        return false;
                    }
                }
            }
            state.domain_size = D0_size >> 1;
            for(uint64 j = 0; j < batches_num;){
                if(!copy_pairs_and_check(blob, state.initial_data_offset, state.leaf_data, state.batch_sizes[j], state.initial_proof_offset)){
                    console.log("Error in initial mekle proof");
                    return false;
                }
                state.leaf_length = state.batch_sizes[j] * 0x40;
                state.initial_data_offset += state.batch_sizes[j] * 0x40;
                state.initial_proof_offset = merkle_verifier.skip_merkle_proof_be(blob, state.initial_proof_offset);
                j++;
            }
            for( uint64 p = 0; p < unique_points; p++){
                state.denominators[p][0] = addmod(state.x, modulus - state.unique_eval_points[p], modulus);
                state.denominators[p][1] = addmod(modulus - state.x, modulus - state.unique_eval_points[p], modulus);
                state.denominators[p][0] = field.inverse_static(state.denominators[p][0], modulus);
                state.denominators[p][1] = field.inverse_static(state.denominators[p][1], modulus);
            }
            state.denominators[unique_points][0] = addmod(state.x, modulus - _eta, modulus);
            state.denominators[unique_points][1] = addmod(modulus - state.x, modulus - _eta, modulus);
            state.denominators[unique_points][0] = field.inverse_static(state.denominators[unique_points][0], modulus);
            state.denominators[unique_points][1] = field.inverse_static(state.denominators[unique_points][1], modulus);

            if(state.x_index >= state.domain_size){
                for( uint64 p = 0; p < unique_points + 1; p++ ){
                    uint256 tmp;
                    tmp = state.denominators[p][0];
                    state.denominators[p][0] = state.denominators[p][1];
                    state.denominators[p][1] = tmp;
                }
            }

            prepare_Y(blob, state.query_proof_offset, state);
            if( !copy_memory_pair_and_check(blob, state.round_proof_offset, state.leaf_data, state.y) ){
                console.log("Not validated!");
                return false;
            }
            if( state.x_index % (state.domain_size) < state.domain_size/2){
                state.interpolant = basic_marshalling.get_uint256_be(blob,state.round_data_offset);
            } else {
                state.interpolant = basic_marshalling.get_uint256_be(blob,state.round_data_offset + 0x20);
            }
            if( state.x_index < state.domain_size ) {
                if( !colinear_check(state.x, state.y, state.alphas[0], state.interpolant) ){
                    console.log("Colinear check failed");
                    return false;
                }
            } else {
                if( !colinear_check(modulus - state.x, state.y, state.alphas[0], state.interpolant) ){
                    console.log("Colinear check failed");
                    return false;
                }
            }

            state.round_proof_offset = merkle_verifier.skip_merkle_proof_be(blob, state.round_proof_offset);
            for(state.j = 1; state.j < r;){
                state.x_index %= state.domain_size;
                state.x = mulmod(state.x, state.x, modulus);
                state.domain_size >>= 1;
                if(!copy_pairs_and_check(blob, state.round_data_offset, state.leaf_data, 1, state.round_proof_offset)) {
                    console.log("Error in round mekle proof");
                    return false;
                }
                state.y[0] = basic_marshalling.get_uint256_be(blob, state.round_data_offset);
                state.y[1] = basic_marshalling.get_uint256_be(blob, state.round_data_offset + 0x20);
                if( state.x_index % (state.domain_size) < state.domain_size/2){
                    state.interpolant = basic_marshalling.get_uint256_be(blob,state.round_data_offset + 0x40);
                } else {
                    state.interpolant = basic_marshalling.get_uint256_be(blob,state.round_data_offset + 0x60);
                }
                if( state.x_index < state.domain_size ) {
                    if( !colinear_check(state.x, state.y, state.alphas[state.j], state.interpolant) ){
                        console.log("Round colinear check failed", state.j);
                        return false;
                    }
                } else {
                    if( !colinear_check(modulus - state.x, state.y, state.alphas[state.j], state.interpolant) ){
                        console.log("Round colinear check failed", state.j);
                        return false;
                    }
                }
                state.j++; state.round_data_offset += 0x40;
                state.round_proof_offset = merkle_verifier.skip_merkle_proof_be(blob, state.round_proof_offset);
            }

            state.x = mulmod(state.x, state.x, modulus);
            state.x_index = state.x_index%state.domain_size;
            if( state.x_index % state.domain_size/2 < state.domain_size/4 ){
                state.y[0] = basic_marshalling.get_uint256_be(blob, state.round_data_offset);
                state.y[1] = basic_marshalling.get_uint256_be(blob, state.round_data_offset + 0x20);
            } else {
                state.y[0] = basic_marshalling.get_uint256_be(blob, state.round_data_offset + 0x20);
                state.y[1] = basic_marshalling.get_uint256_be(blob, state.round_data_offset);
            }

            if(polynomial.evaluate(state.final_polynomial, state.x, modulus) != state.y[0]) {
                console.log("Wrong final poly check", polynomial.evaluate(state.final_polynomial, state.x, modulus));
                console.log(state.y[0]);
//                return false;
            }
            if(polynomial.evaluate(state.final_polynomial, modulus - state.x, modulus) != state.y[1]){
                console.log("Wrong final poly check",polynomial.evaluate(state.final_polynomial, modulus-state.x, modulus));
                console.log(state.y[1]);
//                return false;
            }
            state.round_data_offset += 0x40;
            i++;
        }
        return true;
}
    }
}
    